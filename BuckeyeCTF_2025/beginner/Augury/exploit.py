#!/usr/bin/env python3
"""
Exploit for Augury challenge.

Connects to the remote service, lists files, fetches encrypted hex for candidate files,
and attempts decryption assuming common flag prefixes. The encryption uses a 32-bit
seed derived from SHAKE-128(password) for the first 4 bytes, then an LCG:

    s_{n+1} = (a * s_n + c) mod 2**32

with a=3404970675, c=3553295105.

We take the first 4 bytes of the ciphertext, XOR with guessed 4-byte plaintext prefix
to get the initial seed. Then run the LCG to decrypt the rest.

Usage:
  pip install pwntools
  python3 exploit.py

If you cannot use pwntools, you can adapt the logic to raw sockets / ncat.
"""

from pwn import remote

A = 3404970675
C = 3553295105
MOD = 2 ** 32


def lcg_next(s):
    return (s * A + C) % MOD


def decrypt_with_seed(cipher_bytes, seed):
    s = seed
    out = bytearray()
    i = 0
    while i < len(cipher_bytes):
        key = s.to_bytes(4, 'big')
        # XOR up to 4 bytes
        for j in range(4):
            if i + j >= len(cipher_bytes):
                break
            out.append(cipher_bytes[i + j] ^ key[j])
        i += 4
        s = lcg_next(s)
    return bytes(out)


def try_decrypt_candidates(cipher_hex):
    cipher = bytes.fromhex(cipher_hex)
    first_block = cipher[:4]

    # common 4-byte prefixes to try (first 4 bytes of possible flags)
    candidates = [b'bctf']

    for cand in candidates:
        # If candidate shorter than 4, pad? we only use 4-byte candidates
        if len(cand) != 4:
            continue
        seed = int.from_bytes(bytes(a ^ b for a, b in zip(first_block, cand)), 'big')
        plain = decrypt_with_seed(cipher, seed)
        if b'}' in plain or b'flag' in plain.lower():
            return plain.decode(errors='ignore')

    # If not found, try brute-forcing last byte of prefix 'flag{' (i.e. try 'f','l','a','g' is already tried)
    # Also try brute-forcing if we only know first 3 bytes (rare). As fallback, try all 256 possibilities for last byte
    import itertools, string
    printable = bytes(string.ascii_letters + string.digits + "_{}-!@#$%^&*()", 'ascii')
    for cand in itertools.product(printable, repeat=4):
        candb = bytes(cand)
        seed = int.from_bytes(bytes(a ^ b for a, b in zip(first_block, candb)), 'big')
        plain = decrypt_with_seed(cipher, seed)
        if b'}' in plain and all(32 <= x < 127 for x in plain[:20]):
            return plain.decode(errors='ignore')

    return None


def run():
    host = "augury.challs.pwnoh.io"
    port = 1337

    print("Connecting to remote...")
    r = remote(host, port, ssl=True)

    # read welcome and menu
    r.recvuntil(b"Please select an option:")
    r.recvline()
    r.recvline()
    r.recvline()

    # choose View Files (option 2)
    r.sendline(b"2")

    # Service prints "Available files:" then names, then "Choose a file to get"
    data = r.recvuntil(b"Choose a file to get", drop=True).decode()
    # parse file names (lines after Available files:)
    lines = [l.strip() for l in data.splitlines()]
    files = []
    try:
        idx = lines.index('Available files:')
        files = [x for x in lines[idx+1:] if x]
    except ValueError:
        # just take any lines that look like names
        files = [x for x in lines if x]

    print("Files:", files)

    # Prefer files with 'flag' in name
    candidates = [f for f in files if 'flag' in f.lower()]
    if not candidates:
        candidates = files

    for fname in candidates:
        print("Trying file:", fname)
        r.sendline(fname.encode())
        # server prints hex
        hexdata = r.recvline().strip().decode()
        print("Encrypted hex (len=%d): %s..." % (len(hexdata), hexdata[:80]))
        plain = try_decrypt_candidates(hexdata)
        if plain:
            print("Possible plaintext for file", fname)
            print(plain)
            return
        else:
            print("No candidate plaintext found for", fname)

    print("Exploit finished, no flag found")


if __name__ == '__main__':
    run()
