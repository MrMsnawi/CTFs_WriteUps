#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <inttypes.h>

int main(void) {
    /* substitution table (same as in the binary) */
    uint8_t d[] = {
        0x56,0x62,0x00,0x55,0x61,0x1a,0x17,0x2a,0x7b,0x3b,0x04,0x2e,0x59,0x4d,0x47,0x5c,
        0x08,0x6e,0x3d,0x5a,0x50,0x33,0x14,0x1e,0x21,0x70,0x25,0x5d,0x7c,0x07,0x77,0x02,
        0x7f,0x0b,0x1d,0x1b,0x72,0x63,0x2c,0x68,0x0c,0x48,0x3a,0x73,0x78,0x11,0x4f,0x37,
        0x01,0x42,0x30,0x06,0x6c,0x27,0x76,0x4c,0x7a,0x15,0x64,0x5b,0x24,0x38,0x0d,0x5e,
        0x40,0x54,0x34,0x1f,0x51,0x03,0x13,0x0e,0x74,0x26,0x52,0x09,0x6b,0x32,0x4a,0x44,
        0x66,0x67,0x6d,0x22,0x79,0x6a,0x10,0x4b,0x39,0x71,0x1c,0x2f,0x3c,0x16,0x43,0x28,
        0x05,0x53,0x2b,0x23,0x29,0x3e,0x60,0x4e,0x0f,0x2d,0x20,0x12,0x5f,0x75,0x45,0x57,
        0x58,0x36,0x46,0x31,0x7d,0x69,0x7e,0x35,0x49,0x19,0x3f,0x18,0x41,0x6f,0x65
    };
    const size_t D_SZ = sizeof(d) / sizeof(d[0]);

    /* inverse table: initialize to 0xFF = invalid */
    uint8_t inv[256];
    for (size_t i = 0; i < sizeof(inv); ++i) inv[i] = 0xFF;

    for (uint16_t i = 0; i < D_SZ; ++i) {
        inv[ d[i] ] = (uint8_t)i;
    }

    /* constants from the decompilation (enc and local_40) */
    uint64_t enc_val    = 0x63675168646a4976ULL;
    uint64_t local_40   = 0x757141444e694573ULL;

    /* produce the 16-byte target in little-endian order (LSB first) */
    uint8_t target[16];
    for (int j = 0; j < 8; ++j) {
        target[j]     = (uint8_t)((enc_val  >> (8 * j)) & 0xFF);
        target[8 + j] = (uint8_t)((local_40 >> (8 * j)) & 0xFF);
    }

    /* recover key bytes by inverting d[] */
    uint8_t key[16];
    for (int i = 0; i < 16; ++i) {
        uint8_t tb = target[i];
        if (inv[tb] == 0xFF) {
            fprintf(stderr, "Error: target byte 0x%02x has no inverse in d[]\n", tb);
            return 1;
        }
        key[i] = inv[tb];
    }
    for (int i = 0; i < 16; ++i)
        printf("%c", key[i]);
    return 0;
}
